<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>dotnet on fissssssh</title><link>https://fissssssh.com/tags/dotnet/</link><description>Recent content in dotnet on fissssssh</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 14 Dec 2022 22:25:34 +0800</lastBuildDate><atom:link href="https://fissssssh.com/tags/dotnet/index.xml" rel="self" type="application/rss+xml"/><item><title>ASP.NET Core 中使用 Dapr 发布订阅</title><link>https://fissssssh.com/posts/dapr-publish-and-subscription-in-asp-net-core/</link><pubDate>Wed, 14 Dec 2022 22:25:34 +0800</pubDate><guid>https://fissssssh.com/posts/dapr-publish-and-subscription-in-asp-net-core/</guid><description>定义 subpub 组件 我们使用 Dapr 初始化时安装的 redis 作为 pubsub 的实现
创建文件 ~/.dapr/components/pubsub.yaml （Windows 用户为 %USERPROFILE%\.dapr\components\pubsub.yaml ），内容如下
Dapr 初始化后 ~/.dapr/components 文件夹会自动创建，里面有一个 statestore.yaml 的组件定义。如果没有该文件夹也不用担心，手动创建即可
apiVersion: dapr.io/v1alpha1 kind: Component metadata: name: pubsub spec: type: pubsub.redis version: v1 metadata: - name: redisHost value: localhost:6379 - name: redisPassword value: &amp;#34;&amp;#34; 创建项目 创建 ASP.NET Core WebAPI 项目
$ dotnet new webapi --no-openapi --no-https 安装 Dapr SDK
dotnet CLI
$ dotnet add package Dapr.AspNetCore 程序包管理器控制台
Install-Package Dapr.AspNetCore 也可以在 Visual Studio 的 Nuget 包管理器中搜索安装</description></item><item><title>如何在 ASP.NET Core WEB API 中启动后台任务</title><link>https://fissssssh.com/posts/how-to-start-backgroud-task-in-asp_net_core_webapi/</link><pubDate>Mon, 27 Jun 2022 20:30:49 +0800</pubDate><guid>https://fissssssh.com/posts/how-to-start-backgroud-task-in-asp_net_core_webapi/</guid><description>引言 有时候我们可能想在接口中开启一个后台任务，就像这样:
public class MyController : Controller { private readonly MyDependency _dep; public MyController(MyDependency d) { _dep = d; } public IActionResult MyAction() { Task.Run(() =&amp;gt; _dep.DoHeavyAsyncWork()); return Json(&amp;#34;Your job is started!&amp;#34;); } } 事实上，这段代码很符合语义，接口也能成功返回。 但是其中有一个潜在问题，随着return语句响应本次请求，ASP.NET Core会开始释放本次请求的依赖，比如控制器和控制器依赖的各种服务……，这就会导致Task.Run语句中的所依赖的定义在控制器中的服务会被释放掉，这可能会导致一些未知的问题。这些潜在问题可能会让你的应用程序随时爆炸！
让后台任务拥有自己的生存期 为了保证后台服务的依赖不随控制器释放而释放，我们需要定义一个新的服务并将其注册为单例服务，因为单例服务永远不会被释放。
创建一个名为CannonService的类
CannonService.cs
public class CannonService { private readonly ILogger&amp;lt;CannonService&amp;gt; _logger; private readonly IServiceProvider _serviceProvider; public CannonService(ILogger&amp;lt;CannonService&amp;gt; logger, IServiceProvider serviceProvider) { _logger = logger; _serviceProvider = serviceProvider; } public void Fire(Delegate dg, Action&amp;lt;Exception&amp;gt;?</description></item></channel></rss>