<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>dotnet on fissssssh</title><link>https://blog.fissssssh.com/tags/dotnet/</link><description>Recent content in dotnet on fissssssh</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 04 Feb 2023 13:57:23 +0800</lastBuildDate><atom:link href="https://blog.fissssssh.com/tags/dotnet/index.xml" rel="self" type="application/rss+xml"/><item><title>生成 HTTP 查询字符串</title><link>https://blog.fissssssh.com/posts/generate-http-query-string/</link><pubDate>Sat, 04 Feb 2023 13:57:23 +0800</pubDate><guid>https://blog.fissssssh.com/posts/generate-http-query-string/</guid><description>什么是 HTTP 查询字符串 例如此 URL：https://example.com:80/query?key1=value2&amp;amp;key2=value2
对其拆解我们可以得到以下部分：
https：协议 :// example.com：域名 :80：端口 /query：路径 ?key1=value2&amp;amp;key2=value2：参数（也称作查询字符串） 如何生成 HTTP 查询字符串 暴力拼接 略
System.Web.HttpUtility var query = HttpUtility.ParseQueryString(string.Empty); query[&amp;#34;a+b&amp;#34;] = &amp;#34;a%b&amp;#34;; query[&amp;#34;b&amp;#34;] = &amp;#34;2+1&amp;#34;; var queryString = query.ToString(); // a+b=a%25b&amp;amp;b=2%2b1 HttpUtility.ParseQueryString(string.Empty) 会返回一个空的NameValueCollection，你只需要往里面填充参数然后调用ToString()即可生成查询字符串
您不能使用 new NameValueCollection() 来达到同样的效果，因为 HttpUtility.ParseQueryString(string) 返回的实际是 HttpQSCollection 类型，该类型是 NameValueCollection 的派生类型且不对外公开，所以你也无法通过 new 关键字来创建 HttpQSCollection 类型
此方法生成的查询字符串只会转义 value 且不包含前导字符 ?
Microsoft.AspNetCore.Http.QueryString 此方法仅适用于 SDK 为 Microsoft.NET.Sdk.Web 的项目
var queryString = QueryString.Create(new Dictionary&amp;lt;string, string?&amp;gt; { [&amp;#34;a+b&amp;#34;] = &amp;#34;a%b&amp;#34;, [&amp;#34;b&amp;#34;] = &amp;#34;2+1&amp;#34;, }).</description></item><item><title>ASP.NET Core 中使用 Dapr 发布订阅</title><link>https://blog.fissssssh.com/posts/dapr-publish-and-subscription-in-asp-net-core/</link><pubDate>Wed, 14 Dec 2022 22:25:34 +0800</pubDate><guid>https://blog.fissssssh.com/posts/dapr-publish-and-subscription-in-asp-net-core/</guid><description>定义 subpub 组件 我们使用 Dapr 初始化时安装的 redis 作为 pubsub 的实现
创建文件 ~/.dapr/components/pubsub.yaml （Windows 用户为 %USERPROFILE%\.dapr\components\pubsub.yaml ），内容如下
Dapr 初始化后 ~/.dapr/components 文件夹会自动创建，里面有一个 statestore.yaml 的组件定义。如果没有该文件夹也不用担心，手动创建即可
apiVersion: dapr.io/v1alpha1 kind: Component metadata: name: pubsub spec: type: pubsub.redis version: v1 metadata: - name: redisHost value: localhost:6379 - name: redisPassword value: &amp;#34;&amp;#34; 创建项目 创建 ASP.NET Core WebAPI 项目
$ dotnet new webapi --no-openapi --no-https 安装 Dapr SDK
dotnet CLI
$ dotnet add package Dapr.AspNetCore 程序包管理器控制台
Install-Package Dapr.AspNetCore 也可以在 Visual Studio 的 Nuget 包管理器中搜索安装</description></item><item><title>如何在 ASP.NET Core WEB API 中启动后台任务</title><link>https://blog.fissssssh.com/posts/how-to-start-backgroud-task-in-asp_net_core_webapi/</link><pubDate>Mon, 27 Jun 2022 20:30:49 +0800</pubDate><guid>https://blog.fissssssh.com/posts/how-to-start-backgroud-task-in-asp_net_core_webapi/</guid><description>引言 有时候我们可能想在接口中开启一个后台任务，就像这样:
public class MyController : Controller { private readonly MyDependency _dep; public MyController(MyDependency d) { _dep = d; } public IActionResult MyAction() { Task.Run(() =&amp;gt; _dep.DoHeavyAsyncWork()); return Json(&amp;#34;Your job is started!&amp;#34;); } } 事实上，这段代码很符合语义，接口也能成功返回。 但是其中有一个潜在问题，随着return语句响应本次请求，ASP.NET Core会开始释放本次请求的依赖，比如控制器和控制器依赖的各种服务……，这就会导致Task.Run语句中的所依赖的定义在控制器中的服务会被释放掉，这可能会导致一些未知的问题。这些潜在问题可能会让你的应用程序随时爆炸！
让后台任务拥有自己的生存期 为了保证后台服务的依赖不随控制器释放而释放，我们需要定义一个新的服务并将其注册为单例服务，因为单例服务永远不会被释放。
创建一个名为CannonService的类
CannonService.cs
public class CannonService { private readonly ILogger&amp;lt;CannonService&amp;gt; _logger; private readonly IServiceProvider _serviceProvider; public CannonService(ILogger&amp;lt;CannonService&amp;gt; logger, IServiceProvider serviceProvider) { _logger = logger; _serviceProvider = serviceProvider; } public void Fire(Delegate dg, Action&amp;lt;Exception&amp;gt;?</description></item></channel></rss>