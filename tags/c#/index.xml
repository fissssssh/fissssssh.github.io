<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>C# on fissssssh</title><link>https://blog.fissssssh.com/tags/c#/</link><description>Recent content in C# on fissssssh</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 17 Jan 2023 17:06:58 +0800</lastBuildDate><atom:link href="https://blog.fissssssh.com/tags/c#/index.xml" rel="self" type="application/rss+xml"/><item><title>Newtonsoft.Json 小技巧</title><link>https://blog.fissssssh.com/posts/newtonsoft-json-tips/</link><pubDate>Tue, 17 Jan 2023 17:06:58 +0800</pubDate><guid>https://blog.fissssssh.com/posts/newtonsoft-json-tips/</guid><description>Newtonsoft.Json 是一个非常受欢迎的 .NET JSON 框架
一般来说大部分用户用到的方法主要就是 JsonConvert.SerializeObject 和 JsonConvert.DeserializeObject 方法
前者用于将 .NET 对象 序列化为 JSON 字符串，后者则是将 JSON 字符串反序列化为 .NET 对象
下面我将讲述一些你可能用过或者没用过的一些小技巧
填充对象 我现在有一个 {&amp;quot;name&amp;quot;:&amp;quot;fissssssh&amp;quot;} JSON 对象，当将它转为Dictionary&amp;lt;string,string&amp;gt;后，可以通过键名name获取属性值
然而这个 JSON 现在变成 {&amp;quot;Name&amp;quot;:&amp;quot;fissssssh&amp;quot;}, 无法再通过键名 name 获取属性值
Dictionary 是支持替换键名比较器的，但是 JsonConvert.DeserializeObject 只会调用其无参构造函数
我们可以手动将 Dictionary 创建出来, 然后通过 JsonConvert.PopulateObject 方法将 JSON 字符串序列化并填充至指定对象，代码如下
var json = &amp;#34;{\&amp;#34;Name\&amp;#34;:\&amp;#34;fissssssh\&amp;#34;}&amp;#34;; // 创建一个键名忽略大小写的字典对象 var dict = new Dictionary&amp;lt;string,string&amp;gt;(StringComparer.InvariantCultureIgnoreCase); JsonConvert.PopulateObject(json, dict); // 使用 name 获取 JSON 中的 Name 属性值 var name = dict[&amp;#34;name&amp;#34;];</description></item><item><title>ASP.NET Core 中使用 Dapr 发布订阅</title><link>https://blog.fissssssh.com/posts/dapr-publish-and-subscription-in-asp-net-core/</link><pubDate>Wed, 14 Dec 2022 22:25:34 +0800</pubDate><guid>https://blog.fissssssh.com/posts/dapr-publish-and-subscription-in-asp-net-core/</guid><description>定义 subpub 组件 我们使用 Dapr 初始化时安装的 redis 作为 pubsub 的实现
创建文件 ~/.dapr/components/pubsub.yaml （Windows 用户为 %USERPROFILE%\.dapr\components\pubsub.yaml ），内容如下
Dapr 初始化后 ~/.dapr/components 文件夹会自动创建，里面有一个 statestore.yaml 的组件定义。如果没有该文件夹也不用担心，手动创建即可
apiVersion: dapr.io/v1alpha1 kind: Component metadata: name: pubsub spec: type: pubsub.redis version: v1 metadata: - name: redisHost value: localhost:6379 - name: redisPassword value: &amp;#34;&amp;#34; 创建项目 创建 ASP.NET Core WebAPI 项目
$ dotnet new webapi --no-openapi --no-https 安装 Dapr SDK
dotnet CLI
$ dotnet add package Dapr.AspNetCore 程序包管理器控制台
Install-Package Dapr.AspNetCore 也可以在 Visual Studio 的 Nuget 包管理器中搜索安装</description></item><item><title>如何在 ASP.NET Core WEB API 中启动后台任务</title><link>https://blog.fissssssh.com/posts/how-to-start-backgroud-task-in-asp_net_core_webapi/</link><pubDate>Mon, 27 Jun 2022 20:30:49 +0800</pubDate><guid>https://blog.fissssssh.com/posts/how-to-start-backgroud-task-in-asp_net_core_webapi/</guid><description>引言 有时候我们可能想在接口中开启一个后台任务，就像这样:
public class MyController : Controller { private readonly MyDependency _dep; public MyController(MyDependency d) { _dep = d; } public IActionResult MyAction() { Task.Run(() =&amp;gt; _dep.DoHeavyAsyncWork()); return Json(&amp;#34;Your job is started!&amp;#34;); } } 事实上，这段代码很符合语义，接口也能成功返回。 但是其中有一个潜在问题，随着return语句响应本次请求，ASP.NET Core会开始释放本次请求的依赖，比如控制器和控制器依赖的各种服务……，这就会导致Task.Run语句中的所依赖的定义在控制器中的服务会被释放掉，这可能会导致一些未知的问题。这些潜在问题可能会让你的应用程序随时爆炸！
让后台任务拥有自己的生存期 为了保证后台服务的依赖不随控制器释放而释放，我们需要定义一个新的服务并将其注册为单例服务，因为单例服务永远不会被释放。
创建一个名为CannonService的类
CannonService.cs
public class CannonService { private readonly ILogger&amp;lt;CannonService&amp;gt; _logger; private readonly IServiceProvider _serviceProvider; public CannonService(ILogger&amp;lt;CannonService&amp;gt; logger, IServiceProvider serviceProvider) { _logger = logger; _serviceProvider = serviceProvider; } public void Fire(Delegate dg, Action&amp;lt;Exception&amp;gt;?</description></item></channel></rss>