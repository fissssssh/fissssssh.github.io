<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>文章 on fissssssh</title><link>https://blog.fissssssh.com/posts/</link><description>Recent content in 文章 on fissssssh</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Mon, 08 May 2023 15:48:23 +0800</lastBuildDate><atom:link href="https://blog.fissssssh.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>在 ASP.NET Core 中使用 Serilog</title><link>https://blog.fissssssh.com/posts/use_serilog_in_asp_net_core/</link><pubDate>Mon, 08 May 2023 15:48:23 +0800</pubDate><guid>https://blog.fissssssh.com/posts/use_serilog_in_asp_net_core/</guid><description>添加 Serilog 包引用 $ dotnet add package Serilog.AspNetCore $ dotnet add package Serilog.Sinks.Async 通过上方指令我们添加了以下两个包：
Serilog.AspNetCore
Serilog.AspNetCore 是基于 Serilog 框架的一个扩展库，用于在 ASP.NET Core 应用程序中使用 Serilog 来记录日志。它提供了一些方便的方法来集成 Serilog 框架到 ASP.NET Core 应用程序中，并支持从请求上下文中自动提取一些默认的日志信息，例如 HTTP 请求方法、路径和响应状态码等。通过使用 Serilog.AspNetCore，您可以轻松地将高质量日志记录添加到您的 ASP.NET Core 应用程序中。
Serilog.Sinks.Async
Serilog.Sinks.Async 是 Serilog 库中的一个 sinks 扩展，用于异步地将日志事件写入目标存储。通过使用 Serilog.Sinks.Async，您可以避免在应用程序中引入 IO 操作的性能损失，从而提高应用程序的整体性能。
配置 Serilog 支持使用 appsettings.json 进行配置
在 appsettings.json 根节点下新增 Serilog 节点来配置 Serilog
{ &amp;#34;Serilog&amp;#34;: { // 引用的 Serilog 的 sink，这里使用了 console、file、async 三种 &amp;#34;Using&amp;#34;: [&amp;#34;Serilog.Sinks.Console&amp;#34;, &amp;#34;Serilog.Sinks.File&amp;#34;, &amp;#34;Serilog.Sinks.Async&amp;#34;], // Serilog 对于不同的 logger 进行最小记录级别的配置 &amp;#34;MinimumLevel&amp;#34;: { // 默认为 Information &amp;#34;Default&amp;#34;: &amp;#34;Information&amp;#34;, &amp;#34;Override&amp;#34;: { // 对于 Microsoft 和 System 命名空间下的 logger，级别为 Warning &amp;#34;Microsoft&amp;#34;: &amp;#34;Warning&amp;#34;, &amp;#34;System&amp;#34;: &amp;#34;Warning&amp;#34; } }, // 日志输出配置 &amp;#34;WriteTo&amp;#34;: [ // 将日志输出到 Console { &amp;#34;Name&amp;#34;: &amp;#34;Console&amp;#34; }, // 将日志输出到 File，同时使用 Async wrapper，可以让日志以异步方式写入文件 { &amp;#34;Name&amp;#34;: &amp;#34;Async&amp;#34;, // 使用 Async wrapper 提高日志写入文件性能 &amp;#34;Args&amp;#34;: { &amp;#34;configure&amp;#34;: [ { &amp;#34;Name&amp;#34;: &amp;#34;File&amp;#34;, &amp;#34;Args&amp;#34;: { &amp;#34;path&amp;#34;: &amp;#34;Logs/log.</description></item><item><title>使用Filebeat Sidecar在Kubernetes中收集容器日志</title><link>https://blog.fissssssh.com/posts/using_filebeat_sidecar_to_collect_container_logs_in_kubernetes/</link><pubDate>Tue, 25 Apr 2023 17:26:40 +0800</pubDate><guid>https://blog.fissssssh.com/posts/using_filebeat_sidecar_to_collect_container_logs_in_kubernetes/</guid><description>当今时代，Kubernetes 已成为了容器编排的事实标准。但是，在处理容器日志时，需要一种高效而可靠的方式来将数据从容器发送到日志分析工具中进行分析。本文将介绍如何部署并使用 Filebeat 收集容器日志器，并将数据通过 Logstash 传输到日志聚合平台。本文的重点是 Filebeat 部署，有关 Logstash 的问题请阅读《如何使用 Logstash 将日志写入阿里云 SLS 服务》
简介 Filebeat Filebeat 是 Elastic 公司开源的、高性能的轻量级日志数据收集器，可以自动化地收集和汇总多种不同来源的日志数据，然后将其发送到 Elasticsearch 和 Logstash 等不同种类的日志分析工具中。Filebeat 的设计目标是为了方便用户在不同的场景中使用，同时确保运行的高效性和可靠性。
准备工作 首先我们需要一个可以产生日志的应用，假设该应用部署文件如下：
apiVersion: apps/v1 kind: Deployment metadata: name: my-app labels: app: my-app spec: replicas: 1 selector: matchLabels: app: my-app template: metadata: labels: app: my-app spec: containers: - name: my-app image: my-app:v1.0.0 ports: - name: web containerPort: 80 该应用会往容器的 /app/Logs/ 路径下输出多个日志文件，文件命名格式为 log&amp;lt;suffix&amp;gt;.txt
部署 Filebeat Sidecar 挂载日志目录 为了使 Filebeat 能够采集到 my-app 的日志，我们需要使用 volume 来挂载日志目录，这里选用 emptyDir 卷来挂载日志目录</description></item><item><title>如何使用Logstash将日志写入阿里云SLS服务</title><link>https://blog.fissssssh.com/posts/how-to-write-logs-to-aliyun-sls-using-logstash/</link><pubDate>Mon, 24 Apr 2023 16:22:05 +0800</pubDate><guid>https://blog.fissssssh.com/posts/how-to-write-logs-to-aliyun-sls-using-logstash/</guid><description>当你的应用程序越来越大，日志的管理变得越来越困难。而将日志存储在云服务上是现代化应用中的一个不可忽视的方面。在云服务中，阿里云 SLS 是一个非常好的选择，它可以帮助你收集、存储和查询应用程序日志。但是，如何将应用程序的日志发送到阿里云 SLS 服务呢？今天，我们将使用 Logstash，一个流行的开源工具，来将我们的日志发送到阿里云 SLS 服务中。
简介 阿里云 SLS 服务 阿里云 SLS（云监控日志服务）是一种高可靠、高扩展性的日志服务，主要用于收集和实时处理来自服务器、应用程序和云产品的日志数据。 SLS 提供了实时的查询、统计和报警等功能，有助于用户更轻松地管理日志。
SLS 支持大规模的日志数据处理，可以通过多种方式上传日志数据，例如 SDK、API、SLS Agent、Logstash 等，使用 SLS 可以快速查询、分析和可视化日志数据，帮助用户更好地理解自己的应用环境。
Logstash Logstash 则是一款通用的日志收集工具，可以将来自不同来源的日志数据进行收集、处理、转换和传输。Logstash 可以与各种插件配合使用，从而实现更多功能。例如，用户可以使用 Logstash 的 input 插件来收集来自多个来源的日志数据，使用 filter 插件来解析、过滤和重构这些数据，最后使用 output 插件将处理后的数据发送到各种目的地，如 Elasticsearch、Kibana 等。
准备工作 创建阿里云 SLS 服务实例 略
安装 Logstash 本文使用的 Logstash 版本为 8.7.0（截至本文发布最新版）
阿里云官方文档介绍了如何安装 Logstash，但如果要在 K8s 中运行则需要进行一些其他操作：
构建带有 logstash-output-logservice 插件的 Logstash 镜像 编写 Logstash 配置文件 部署至 K8s 构建镜像 通过 Dockerfile 来构建包含 logstash-output-logservice 插件的 Logstash 镜像，文件内容如下：</description></item><item><title>如何正确在 ASP.NET Core 中返回流</title><link>https://blog.fissssssh.com/posts/how-to-return-stream-in-asp_net_core_webapi-correctly/</link><pubDate>Thu, 30 Mar 2023 19:51:13 +0800</pubDate><guid>https://blog.fissssssh.com/posts/how-to-return-stream-in-asp_net_core_webapi-correctly/</guid><description>最近有位朋友说他在接口中使用 File(Stream stream, string contentType) 方法报错，报错内容是
2023-03-30 18:00:36.8882|ERROR|Microsoft.AspNetCore.Server.Kestrel|Connection id &amp;#34;OHMPHOM94BVEL&amp;#34;, Request id &amp;#34;OHMPHOM94BVEL:00000004&amp;#34;: An unhandled exception was thrown by the application. 大致推测是请求接口前或者接口后出的异常，也没有详细信息，于是要来了一份代码，代码（精简版）如下：
// ExcelDocument.cs public class ExcelDocument { public static Stream GetFileStream() { using var fs = new FileStream(&amp;#34;appsettings.json&amp;#34;, FileMode.Open, FileAccess.Read); var ms = new MemoryStream(); fs.CopyTo(ms); return ms; } } // HomeController.cs [HttpGet(&amp;#34;GetFile&amp;#34;)] public IActionResult GetFile() { var stream = ExcelDocument.GetFileStream(); // 原本是application/vnd.ms-excel， 我这里写测试返回的appsettings.json就换了一下 return File(stream, &amp;#34;application/json&amp;#34;); } 这段代码看着没啥问题，我试着请求了一下，果然有报错，我的报错如下：</description></item><item><title>从 K8s 的 Pod 中拷贝大文件</title><link>https://blog.fissssssh.com/posts/copy-large-file-from-k8s-pod/</link><pubDate>Fri, 24 Mar 2023 12:48:02 +0800</pubDate><guid>https://blog.fissssssh.com/posts/copy-large-file-from-k8s-pod/</guid><description>从 K8s 的容器中拷贝文件可以使用kubectl cp命令，但是对于较大的文件（100M 以上）可能就不是很好使了，拷贝过程经常会出现EOF错误
对于较大的文件，我是这样操作的：
压缩
通过压缩可以减小大文件的体积
tar -czvf largefile.tar.gz largefile 此操作也可以用于打包整个文件夹，以便达到拷贝文件夹的目的
分片
对于体积较大的文件，即使压缩后仍然有好几百 M，这时使用kubectl cp也不一定能够拷贝下来，所以需要对其分割
split -b 50M -d largefile.tar.gz largefile.tar.gz 此操作会将largefile.tar.gz按照 50M/每个文件的大小分割为多个文件，-d选项则是使用数字来作为后缀（默认是英文字母）
例如：largefile.tar.gz有 220M，则分割后会变为
largefile.tar.gz00 # 50M largefile.tar.gz01 # 50M largefile.tar.gz02 # 50M largefile.tar.gz03 # 50M largefile.tar.gz04 # 20M 拷贝
使用kubectl cp命令拷贝分割后的文件
kubectl cp &amp;lt;pod-name&amp;gt;:largefile.tar.gz00 largefile.tar.gz00 kubectl cp &amp;lt;pod-name&amp;gt;:largefile.tar.gz00 largefile.tar.gz01 kubectl cp &amp;lt;pod-name&amp;gt;:largefile.tar.gz00 largefile.tar.gz02 kubectl cp &amp;lt;pod-name&amp;gt;:largefile.tar.gz00 largefile.tar.gz03 kubectl cp &amp;lt;pod-name&amp;gt;:largefile.tar.gz00 largefile.tar.gz04 对于多个容器的 Pod,可以使用-c选项指定具体的容器
合并 使用cat命令合并多个文件
cat largefile.</description></item><item><title>Newtonsoft.Json 小技巧</title><link>https://blog.fissssssh.com/posts/newtonsoft-json-tips/</link><pubDate>Sun, 12 Mar 2023 22:27:51 +0800</pubDate><guid>https://blog.fissssssh.com/posts/newtonsoft-json-tips/</guid><description>Newtonsoft.Json 是一个非常受欢迎的 .NET JSON 框架
一般来说大部分用户用到的方法主要就是 JsonConvert.SerializeObject 和 JsonConvert.DeserializeObject 方法
前者用于将 .NET 对象 序列化为 JSON 字符串，后者则是将 JSON 字符串反序列化为 .NET 对象
下面我将讲述一些你可能用过或者没用过的一些小技巧
填充对象 我现在有一个 {&amp;quot;name&amp;quot;:&amp;quot;fissssssh&amp;quot;} JSON 对象，当将它转为Dictionary&amp;lt;string,string&amp;gt;后，可以通过键名name获取属性值
然而这个 JSON 现在变成 {&amp;quot;Name&amp;quot;:&amp;quot;fissssssh&amp;quot;}, 无法再通过键名 name 获取属性值
Dictionary 是支持替换键名比较器的，但是 JsonConvert.DeserializeObject 只会调用其无参构造函数
我们可以手动将 Dictionary 创建出来, 然后通过 JsonConvert.PopulateObject 方法将 JSON 字符串序列化并填充至指定对象，代码如下
var json = &amp;#34;{\&amp;#34;Name\&amp;#34;:\&amp;#34;fissssssh\&amp;#34;}&amp;#34;; // 创建一个键名忽略大小写的字典对象 var dict = new Dictionary&amp;lt;string,string&amp;gt;(StringComparer.InvariantCultureIgnoreCase); JsonConvert.PopulateObject(json, dict); // 使用 name 获取 JSON 中的 Name 属性值 var name = dict[&amp;#34;name&amp;#34;]; 从流进行反序列化 有些情况下我们需要反序列化来自网络请求或者文件中 JSON，它们通常是以流的形式持有，反序列化先将其读取为字符串，当 JSON 内容过大的时候会产生一个巨大的字符串对象，如果此操作比较频繁则会对性能产生比较大的影响</description></item><item><title>重写你的 Git 仓库历史</title><link>https://blog.fissssssh.com/posts/rewrite-git-repo-history/</link><pubDate>Tue, 07 Mar 2023 12:18:15 +0800</pubDate><guid>https://blog.fissssssh.com/posts/rewrite-git-repo-history/</guid><description>在你使用 git 的过程中，你是否有过以下问题：
提交信息写错了 提交了不该提交的文件（例如某些调试过程产生的文件） …… 如果这些问题仅存在于本地，那么有很多种解决办法，比如使用 commit --amend， rebase 等指令，大不了就 reset --mixed 再重新 commit
但是如果你过了好几个甚至好几十个提交才发现这些问题，那么用上述方法就不太好解决了
git-filter-repo git-filter-repo 是一个用于重写历史提交的多功能工具，它和 git filter-branch 比较相似，但是其性能远远优于后者
git 官方也推荐使用 git-filter-repo 而不是 git filter-branch
安装 前置 git &amp;gt;= 2.22.0 at a minimum; some features require git &amp;gt;= 2.24.0 or later python3 &amp;gt;= 3.5 包管理器安装 PACKAGE_TOOL install git-filter-repo 手动安装 下载最新的 Release 解压后将 git-filter-repo 文件复制到 git --exec-path 文件夹下
如果你的 python3 指令被命名为 python ，你还需要将 git-filter-repo 文件第一行中的 python3 改为 python（此问题困扰了大部分 Windows 用户）</description></item><item><title>生成 HTTP 查询字符串</title><link>https://blog.fissssssh.com/posts/generate-http-query-string/</link><pubDate>Sat, 04 Feb 2023 13:57:23 +0800</pubDate><guid>https://blog.fissssssh.com/posts/generate-http-query-string/</guid><description>什么是 HTTP 查询字符串 例如此 URL：https://example.com:80/query?key1=value2&amp;amp;key2=value2
对其拆解我们可以得到以下部分：
https：协议 :// example.com：域名 :80：端口 /query：路径 ?key1=value2&amp;amp;key2=value2：参数（也称作查询字符串） 如何生成 HTTP 查询字符串 暴力拼接 略
System.Web.HttpUtility var query = HttpUtility.ParseQueryString(string.Empty); query[&amp;#34;a+b&amp;#34;] = &amp;#34;a%b&amp;#34;; query[&amp;#34;b&amp;#34;] = &amp;#34;2+1&amp;#34;; var queryString = query.ToString(); // a+b=a%25b&amp;amp;b=2%2b1 HttpUtility.ParseQueryString(string.Empty) 会返回一个空的NameValueCollection，你只需要往里面填充参数然后调用ToString()即可生成查询字符串
您不能使用 new NameValueCollection() 来达到同样的效果，因为 HttpUtility.ParseQueryString(string) 返回的实际是 HttpQSCollection 类型，该类型是 NameValueCollection 的派生类型且不对外公开，所以你也无法通过 new 关键字来创建 HttpQSCollection 类型
此方法生成的查询字符串只会转义 value 且不包含前导字符 ?
Microsoft.AspNetCore.Http.QueryString 此方法仅适用于 SDK 为 Microsoft.NET.Sdk.Web 的项目
var queryString = QueryString.Create(new Dictionary&amp;lt;string, string?&amp;gt; { [&amp;#34;a+b&amp;#34;] = &amp;#34;a%b&amp;#34;, [&amp;#34;b&amp;#34;] = &amp;#34;2+1&amp;#34;, }).</description></item><item><title>在 Hugo 中集成 utterances 评论组件</title><link>https://blog.fissssssh.com/posts/integrate-utterances-in-hugo/</link><pubDate>Tue, 24 Jan 2023 02:22:36 +0800</pubDate><guid>https://blog.fissssssh.com/posts/integrate-utterances-in-hugo/</guid><description>utterances 是基于 GitHub issues 构建的轻量级评论小部件，通过此组件可以将 Github issues 应用于任何网站
前置条件 一个公开的 github repo 在该 repo 中安装utterances app 简单集成 打开utterances官网
在 configuration 节点填写 repo 信息等，填写好后会生成对应的组件代码
我使用的是 PaperMod1 主题，将生成好的代码放入layouts/partials/comments.html
&amp;lt;!--layouts/partials/comments.html--&amp;gt; &amp;lt;script src=&amp;#34;https://utteranc.es/client.js&amp;#34; repo=&amp;#34;[ENTER REPO HERE]&amp;#34; issue-term=&amp;#34;pathname&amp;#34; theme=&amp;#34;github-light&amp;#34; label=&amp;#34;Comment&amp;#34; crossorigin=&amp;#34;anonymous&amp;#34; async &amp;gt;&amp;lt;/script&amp;gt; 然后在config.yaml中开启评论功能即可简单集成
params: comments: true 动态主题适配 PaperMod 有明亮和暗黑两种颜色模式，而 utterances 的主题是编码时就写在script标签中的，为了使 comments 组件的主题适配 PaperMod 颜色主题，有以下两个步骤：
主题动态初始化 &amp;lt;!-- layouts/partials/comments.html --&amp;gt; &amp;lt;script&amp;gt; (function () { let theme = localStorage.getItem(&amp;#34;pref-theme&amp;#34;); // already has prefer theme if (theme) { theme = theme === &amp;#34;dark&amp;#34; ?</description></item><item><title>使用 Visual Studio 调试 dapr 应用程序</title><link>https://blog.fissssssh.com/posts/debug-program-start-by-dapr-with-visual-studio/</link><pubDate>Thu, 05 Jan 2023 15:40:18 +0800</pubDate><guid>https://blog.fissssssh.com/posts/debug-program-start-by-dapr-with-visual-studio/</guid><description>dapr 应用程序是一个多进程程序，对于 Visual Studio 来说可能比较困难
这里介绍两种方法来使用 Visual Studio 调试 dapr 应用程序
使用 VS 扩展 附加进程调试 使用 VS 扩展 参考 https://github.com/dapr/dotnet-sdk/issues/401#issuecomment-747563695
准备条件 安装 PowerShell 7 / Core 也可使用 dotnet tool install --global PowerShell 进行安装
安装 VS 扩展 Microsoft Child Process Debugging Power Tool 2022 调试准备 编辑launchSettings.json
{ &amp;#34;$schema&amp;#34;: &amp;#34;https://json.schemastore.org/launchsettings.json&amp;#34;, &amp;#34;profiles&amp;#34;: { &amp;#34;WebApplication1&amp;#34;: { &amp;#34;commandName&amp;#34;: &amp;#34;Project&amp;#34;, &amp;#34;dotnetRunMessages&amp;#34;: true, &amp;#34;launchBrowser&amp;#34;: true, &amp;#34;launchUrl&amp;#34;: &amp;#34;weatherforecast&amp;#34;, &amp;#34;applicationUrl&amp;#34;: &amp;#34;http://localhost:5217&amp;#34;, &amp;#34;environmentVariables&amp;#34;: { &amp;#34;ASPNETCORE_ENVIRONMENT&amp;#34;: &amp;#34;Development&amp;#34; } }, &amp;#34;Dapr-PWSH&amp;#34;: { &amp;#34;commandName&amp;#34;: &amp;#34;Executable&amp;#34;, &amp;#34;executablePath&amp;#34;: &amp;#34;pwsh&amp;#34;, &amp;#34;commandLineArgs&amp;#34;: &amp;#34;-Command \&amp;#34;dapr run -a myapp -p 5217 -- dotnet run --no-build\&amp;#34;&amp;#34;, &amp;#34;workingDirectory&amp;#34;: &amp;#34;.</description></item><item><title>ASP.NET Core 中使用 Dapr 发布订阅</title><link>https://blog.fissssssh.com/posts/dapr-publish-and-subscription-in-asp-net-core/</link><pubDate>Wed, 14 Dec 2022 22:25:34 +0800</pubDate><guid>https://blog.fissssssh.com/posts/dapr-publish-and-subscription-in-asp-net-core/</guid><description>定义 subpub 组件 我们使用 Dapr 初始化时安装的 redis 作为 pubsub 的实现
创建文件 ~/.dapr/components/pubsub.yaml （Windows 用户为 %USERPROFILE%\.dapr\components\pubsub.yaml ），内容如下
Dapr 初始化后 ~/.dapr/components 文件夹会自动创建，里面有一个 statestore.yaml 的组件定义。如果没有该文件夹也不用担心，手动创建即可
apiVersion: dapr.io/v1alpha1 kind: Component metadata: name: pubsub spec: type: pubsub.redis version: v1 metadata: - name: redisHost value: localhost:6379 - name: redisPassword value: &amp;#34;&amp;#34; 创建项目 创建 ASP.NET Core WebAPI 项目
$ dotnet new webapi --no-openapi --no-https 安装 Dapr SDK
dotnet CLI
$ dotnet add package Dapr.AspNetCore 程序包管理器控制台
Install-Package Dapr.AspNetCore 也可以在 Visual Studio 的 Nuget 包管理器中搜索安装</description></item><item><title>安装 Dapr</title><link>https://blog.fissssssh.com/posts/dapr/install/</link><pubDate>Wed, 14 Dec 2022 16:39:07 +0800</pubDate><guid>https://blog.fissssssh.com/posts/dapr/install/</guid><description>前置条件 Dapr 可以脱离 Docker 运行，但不在本篇所讲范围内，本篇内容中的操作都是基于 Docker 安装完成并运行正常的情况下的操作
Docker Docker 安装官方文档描述十分清晰。 Windows 用户推荐安装带界面的 Docker Desktop（更符合 Windows 人的操作习惯吧），Linux 用户安装 Docker Engine 即可。
开始安装 Dapr 的安装分为两部分：
安装 Dapr CLI 安装 Dapr Runtime 有两种方式可以进行安装，在线安装方式会去 github 下载对应的资源，网络不好的同学可以使用离线安装的方式
在线安装 安装 Dapr CLI
Dapr 官网有各个操作系统详细的安装方法，这里讲一下通用的二进制安装方法：
首先去 Dapr CLI 的发布页（目前最新是 1.9.1 版本）下载对应操作系统版本的压缩包，命名格式为dapr_&amp;lt;os_name&amp;gt;_&amp;lt;cpu_arch&amp;gt;.(tar.gz|zip)，如果操作系统或者 CPU 架构没选对，则 Dapr CLI 无法正常运行 通常来说 Windows 用户下载dapr_windows_amd64.zip，Linux 用户下载dapr_linux_amd64.tar.gz
解压到任意文件夹，并将该文件夹路径加入PATH环境变量 Linux 用户可直接创建软连接到/usr/local/bin/dapr， Windows 用户推荐将文件解压至%USERPROFILE%\bin\文件夹，并将%USERPROFILE%\bin\添加到PATH环境变量中，后续有其他的可执行文件也可以放入该文件夹，不用再动环境变量
打开控制台或者终端输入dapr，如果有相关的内容输出则安装成功 安装 Dapr Runtime
安装 Dapr Runtime 也叫初始化 Dapr。
本地 Dapr 环境的初始化很简单， 只需要dapr init即可</description></item><item><title>Visual Studio 2022 插件推荐</title><link>https://blog.fissssssh.com/posts/recommended-visual-studio-plugins/</link><pubDate>Thu, 07 Jul 2022 16:35:39 +0800</pubDate><guid>https://blog.fissssssh.com/posts/recommended-visual-studio-plugins/</guid><description>引言 插件可以提高开发人员的生产力，好的插件可以让开发事半功倍，下面推荐一些自己用的 Visual Studio 插件（免费！）
插件列表 以下所有插件在 Visual Studio 2022 运行正常，若版本不兼容请移步 Visual Studio Marketplace 查看是否有对应版本
插件名称 描述 CodeMaid VS2022 代码清理插件，其中有一个码锹窗口深得我心 Output enhancer 输出窗口使用彩色优化，错误为红色，警告为黄色等 Code alignment 代码对齐，让你的某些代码按照某个字符垂直对齐 Double-Click Maximize 2022 双击最大化，不用先拖出来再放大，再次双击即可回归原位 Time Stamp Margin 2022 在调试窗口左边增加一列时间戳 Shrink Empty Lines 2022 压缩空行和没有字符的行（只有括号的行）的高度，从而在屏幕上显示更多代码 Solution Error Visualizer 2022 当某个文件有错误或者警告时，在解决方案资源管理器中显示（其父目录也会显示） Match Margin 2022 在滚动条上显示当前选中单词的位置</description></item><item><title>如何在 ASP.NET Core WEB API 中启动后台任务</title><link>https://blog.fissssssh.com/posts/how-to-start-backgroud-task-in-asp_net_core_webapi/</link><pubDate>Mon, 27 Jun 2022 20:30:49 +0800</pubDate><guid>https://blog.fissssssh.com/posts/how-to-start-backgroud-task-in-asp_net_core_webapi/</guid><description>引言 有时候我们可能想在接口中开启一个后台任务，就像这样:
public class MyController : Controller { private readonly MyDependency _dep; public MyController(MyDependency d) { _dep = d; } public IActionResult MyAction() { Task.Run(() =&amp;gt; _dep.DoHeavyAsyncWork()); return Json(&amp;#34;Your job is started!&amp;#34;); } } 事实上，这段代码很符合语义，接口也能成功返回。 但是其中有一个潜在问题，随着return语句响应本次请求，ASP.NET Core会开始释放本次请求的依赖，比如控制器和控制器依赖的各种服务……，这就会导致Task.Run语句中的所依赖的定义在控制器中的服务会被释放掉，这可能会导致一些未知的问题。这些潜在问题可能会让你的应用程序随时爆炸！
让后台任务拥有自己的生存期 为了保证后台服务的依赖不随控制器释放而释放，我们需要定义一个新的服务并将其注册为单例服务，因为单例服务永远不会被释放。
创建一个名为CannonService的类
CannonService.cs
public class CannonService { private readonly ILogger&amp;lt;CannonService&amp;gt; _logger; private readonly IServiceProvider _serviceProvider; public CannonService(ILogger&amp;lt;CannonService&amp;gt; logger, IServiceProvider serviceProvider) { _logger = logger; _serviceProvider = serviceProvider; } public void Fire(Delegate dg, Action&amp;lt;Exception&amp;gt;?</description></item><item><title>Create Redis Cluster by Docker Compose</title><link>https://blog.fissssssh.com/posts/create-redis-cluster-by-docker-compose/</link><pubDate>Tue, 21 Jun 2022 15:52:38 +0800</pubDate><guid>https://blog.fissssssh.com/posts/create-redis-cluster-by-docker-compose/</guid><description>Create a docker-compose.yml version: &amp;#34;3.9&amp;#34; services: redis-1: image: redis:7.0.2-alpine container_name: redis-1 ports: - &amp;#34;6371:6371&amp;#34; - &amp;#34;16371:16371&amp;#34; volumes: - ./node-1/data:/data - ./node-1/conf/redis.conf:/etc/redis/redis.conf networks: redis: ipv4_address: 172.28.0.11 command: - &amp;#34;redis-server&amp;#34; - &amp;#34;/etc/redis/redis.conf&amp;#34; redis-2: image: redis:7.0.2-alpine container_name: redis-2 ports: - &amp;#34;6372:6372&amp;#34; - &amp;#34;16372:16372&amp;#34; volumes: - ./node-2/data:/data - ./node-2/conf/redis.conf:/etc/redis/redis.conf networks: redis: ipv4_address: 172.28.0.12 command: - &amp;#34;redis-server&amp;#34; - &amp;#34;/etc/redis/redis.conf&amp;#34; redis-3: image: redis:7.0.2-alpine container_name: redis-3 ports: - &amp;#34;6373:6373&amp;#34; - &amp;#34;16373:16373&amp;#34; volumes: - ./node-3/data:/data - ./node-3/conf/redis.conf:/etc/redis/redis.conf networks: redis: ipv4_address: 172.</description></item><item><title>Css Integrity Error When Load Hugo Publish</title><link>https://blog.fissssssh.com/posts/css-integrity-error-when-load-hugo-publish/</link><pubDate>Mon, 20 Jun 2022 21:30:04 +0800</pubDate><guid>https://blog.fissssssh.com/posts/css-integrity-error-when-load-hugo-publish/</guid><description>问题描述 近日我使用 hugo 构建了我的博客，并通过 Github Action 将其发布在 Github Pages 上，刚开始还是很美好的，但是过一短时间以后打开页面发现样式全无，使用浏览器的开发者工具查看资源获取没有问题，但是在控制台却出现了这样一句话：
Failed to find a valid digest in the &amp;#39;integrity&amp;#39; attribute for resource &amp;#39;***&amp;#39; with computed SHA-256 integrity &amp;#39;***&amp;#39;. The resource has been blocked. 寻找原因 我在 MDN 上寻找到了关于 integrity 的定义，大概描述就是这是一个签名，浏览器获取到相应资源后会用相同的方法计算一个签名，只有签名相同时才会加载对应的资源，如果两个签名不一致则是文件完整性被破坏（文件发生了改变）。
问题来了，整个发布过程是由 Github Action 全自动操作的，没有人为干预，文件为何会无缘无故改变呢？
答案是 Cloudflare。 Cloudflare 中默认会开启静态资源的缓存来提高网站的加载速度，可是为什么缓存会改变文件呢？缓存并不会改变文件，在 Cloudflare 的 Speed &amp;gt; Optimization 中有一个叫 Auto Minify 的选项，描述如下：
Reduce the file size of source code on your website.
Note: Purge cache to have your change take effect immediately.</description></item><item><title>Code Snippets in VSCode</title><link>https://blog.fissssssh.com/posts/code-snippets.in-vscode/</link><pubDate>Sun, 19 Jun 2022 21:55:10 +0800</pubDate><guid>https://blog.fissssssh.com/posts/code-snippets.in-vscode/</guid><description>Introduction VSCode(Visual Studio Code) is a code editor redefined and optimized for building and debugging modern web and cloud applications.
Code Snippets is a piece of code, the editor will auto complete a specific code when developer type some specific prefixes.
Custom Code Snippets VSCode has many built-in code snippets, so I won&amp;rsquo;t go into details here, but mainly talk about how to customize code snippets.
There are two types of code snippets, one is global and the other is workspace, the difference between them is that the scope and storage location.</description></item><item><title>软件推荐</title><link>https://blog.fissssssh.com/posts/recommended-software/</link><pubDate>Thu, 16 Jun 2022 20:08:22 +0800</pubDate><guid>https://blog.fissssssh.com/posts/recommended-software/</guid><description>以下是我本人平时喜欢用的软件，排名不分先后
名称 描述 类型 7-Zip 压缩软件 desktop Fiddler HTTP 抓包工具 desktop Git 代码管理软件 cli,desktop Google Chrome 顶级浏览器 desktop MPC-HC 视频播放器 desktop MSI Afterburner 性能监视超频软件 desktop MacType Windows 字体渲染 desktop OBS Studio 推流工具 desktop PowerToys Windows 小工具集合 desktop Sourcetree 代码管理软件 desktop ToDesk 远程桌面工具 desktop Virtual Audio Cable 音频管理软件 desktop Visual Studio Code 吃饭的家伙 desktop Visual Studio 吃饭的家伙 desktop Voicemetter Banana 音频管理软件 desktop WinHex 文件查看工具 desktop WinSCP 文件复制工具 desktop WinaeroTweaker Windows 工具 desktop WireShark 网络抓包工具 desktop Wiztree 磁盘分析工具 desktop dnSpy .</description></item></channel></rss>